# 정리노트#6

## 가상함수와 오버라이딩

### 가상함수

- virtual 키워드로 선언된 멤버 함수
- virtual 키워드의 의미
  - 동적 바인딩 지시어
  - 컴파일러에게 함수에 대한 호출 바인딩을 실행 시간까지 미루도록 지시
- 선언예시

```C++
class Base {
public:
  virtual void f(); // f()는 가상 함수
}
```

### 함수 오바라이딩

- 파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언
  - 기본 클래스의 가상 함수의 존재감을 상실시킴
  - 파생클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩
  - 함수 재정의라고도 부름
  - 다형성의 한 종류

- 함수 재정의와 오버라이딩 비교

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/b91b3ad8-adf3-42e7-a34e-bb350c5794dd)

### 동적 바인딩

- 파생 클래스에 대해 기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우
- 객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/11baa5d1-e84b-4348-b219-caa61a7b7908)


### 오버라이딩의 특징

#### 오버라이딩의 성공 조건

- 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 모두 일치해야 함

#### 오버라이딩 시 virtual 지시어 생략 가능

- 가상 함수의 virtual 지시어는 상속됨, 파생 클래스에서 생략 가능

#### 가상 함수의 접근 지정

- private, protected, public 중 자유롭게 지정 가능

### 범위 지정 연산자(::)

- 정적 바인딩 지시
- 기본클래스::가상함수() 형태로 기본 클래스의 가상 함수를 정적 바인딩으로 호출
- 예시

```C++
class Shape {
public:
  virtual void draw() {
    ...
  }
};

class Circle : public Shape {
public:
  virtual void draw() {
    Shape::draw(); // 기본 클래스의 draw()를 실행한다.
    .... // 기능을 추가한다.
  }
};
```

### 가상 소멸자

- 소멸자를 virtual 키워드로 선언
- 소멸자 호출 시 동적 바인딩 발생

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/16950209-507a-4986-8496-1bc5d36817f6)


### 오버로딩, 함수 재정의, 오버라이딩 비교

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/a3d6878d-63ce-4a2d-bfa7-4e1f294c6899)

## 추상 클래스

### 순수 가상 함수

#### 기본 클래스의 가상 함수 목적

- 파생 클래스에서 재정의할 함수를 알려주는 역할
  - 실행할 코드를 작성할 목적이 아님
- 기본 클래스의 가상 함수를 굳이 구현할 필요가 있을까?

#### 순수 가상 함수

- pure virtual function
- 함수의 코드가 없고 선언만 있는 가상 멤버 함수
- 선언 예시

```C++
// 순수 가상 함수 선언
class Shape {
public:
	virtual void draw() = 0;
};
```

### 추상 클래스

#### 추상 클래스란?

- 최소한 하나의 순수 가상 함수를 가진 클래스
- 추상 클래스 예시

```C++
class Shape { // Shape은 추상 클래스
  Shape *next;
public:
  void paint() {
    draw();
  }
  virtual void draw() = 0; // 순수 가상 함수
};

void Shape::paint() {
  draw(); // 순수 가상 함수라도 호출은 할 수 있다.
}
```

#### 추상 클래스의 특징

- 온전한 클래스가 아니므로 객체 생성 불가능
- 추상 클래스의 포인터는 선언 가능

#### 추상 클래스의 목적

- 추상 클래스의 인스턴스를 생성할 목적이 아님
- 상속에서 기본 클래스의 역할을 하기 위함
  - 순수 가상 함수를 통해 파생 클래스에서 구현할 함수의 형태를 보여주는 인터페이스 역할
  - 추상 클래스의 모든 멤버 함수를 순수 가상 함수로 선언할 필요 없음

#### 추상 클래스의 상속

- 추상 클래스를 단순 상속하면 자동 추상 클래스

#### 추상 클래스의 구현

- 추상 클래스를 상속 받아 순수 가상 함수를 오버라이딩
  - 파생 클래스는 추상 클래스가 아님

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/ca30350d-eec4-4f67-9365-0a9e61708610)

