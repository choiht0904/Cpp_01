# 정리노트#7

## 함수 중복의 약점

- 중복 함수의 코드 중복

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/95d30f5c-40d2-4dd1-8446-504aeb370c25)

## 일반화와 템플릿


## 템플릿과 STL(표준 템플릿 라이브러리)

### 일반화와 템플릿

#### 제네릭 또는 일반화

- 함수나 클래스를 일반화시키고, 매개 변수 타입을 지정하여 틀에서 찍어 내듯이 함수나 클래스 코드를 생산하는 기법

#### 템플릿 

- 함수나 클래스를 일반화하는 C++ 도구
- `template` 키워드로 함수나 클래스 선언
    - 변수나 매개 변수의 타입만 다르고, 코드 부분이 동일한 함수를 일반화시킴
- 제네릭 타입 - 일반화를 위한 데이터 타입
- 선언 예시

```C++
// 템플릿을 이용한 제네릭 함수 mySwap
template <class T>
void mySwap(T & a,  T & b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}
```

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/9a9bdb1b-97b3-4ea1-bd1d-e718150175de)

#### 템플릿으로부터의 구체화 

- 구체화
    - 템플릿의 제네릭 타입에 구체적인 타입 지정
        - 템플릿 함수로부터 구체화된 함수의 소스 코드 생성

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/83e0aa4d-d619-4fa6-bbcf-35cc6ae4e4bb)

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/ec7c36b3-f7de-4a2e-92c8-e5d305e7ee1a)

#### 구체화 오류

- 제네릭 타입에 구체적인 타입 지정 시 주의

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/11c0887d-0fc2-4505-9872-dfa72835abfd)

#### 템플릿 장점과 단점

- 템플릿 장점
    - 함수 코드의 재사용
        - 높은 소프트웨어의 생산성과 유용성
- 템플릿 단점
    - 포팅에 취약
        - 컴파일러에 따라 지원하지 않을 수 있음
    - 컴파일 오류 메시지 빈약, 디버깅에 많은 어려움
 
#### 제네릭 프로그래밍

- Generic Programming
    - 일반화 프로그래밍이라고도 부름
    - 제네릭 함수나 제네릭 클래스를 활용하는 프로그래밍 기법
    - C++에서 STL 제공, 활용
- 보편화 추세
    - Java, C# 등 많은 언어에서 활용
 
![image](https://github.com/choiht0904/Cpp_01/assets/77330457/6fa0cda5-d9ba-4a26-a658-d008a7594304)

### C++ 표준 템플릿 라이브러리, STL

#### STL(Standard Template Library)

- 표준 템플릿 라이브러리
    - C++ 표준 라이브러리 중 하나
- 많은 제네릭 클래스와 제네릭 함수 포함
    - 개발자는 이들을 이용하여 쉽게 응용 프로그램 작성

#### STL의 구성

- 컨테이너 - 템플릿 클래스
    - 데이터를 담아두는 자료 구조를 표현한 클래스
    - 리스트, 큐, 스택, 맵, 셋, 벡터
- iterator - 컨테이너 원소에 대한 포인터
    - 컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터
- 알고리즘 - 템플릿 함수
    - 컨테이너 원소에 대한 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿 함수
    - 컨테이너의 멤버 함수 아님

#### STL과 관련된 헤더 파일과 이름 공간

- 헤더 파일
    - 컨테이너 클래스를 사용하기 위한 헤더 파일
        - 해당 클래스가 선언된 헤더 파일 include
    - 알고리즘 함수를 사용하기 위한 헤더 파일
        - 알고리즘 함수에 상관 없이 #include <algorithm>
- 이름 공간
    - STL이 선언된 이름 공간은 std

#### vector 컨테이너

- 특징
- 가변 길이 배열을 구현한 제네릭 클래스
    - 개발자가 벡터의 길이에 대한 고민할 필요 없음
- 원소의 저장, 삭제, 검색 등 다양한 멤버 함수 지원
- 벡터에 저장된 원소는 인덱스로 접근가능
    - 인덱스는 0부터 시작
 
### iterator 사용

#### iterator란?

- 반복자라고도 부름
- 컨테이너의 원소를 가르키는 포인터

#### iterator 변수 선언

- 구체적인 컨테이너를 지정하여 반복자 변수 생성

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/b1ef7549-777f-47c3-b0a6-52ebb6ee88c9)

### map 컨테이너

#### 특징

- `키 : 값` 의 쌍을 원소로 저장하는 제네릭 컨테이너
    - 동일한 키를 가진 원소가 중복 저장되면 오류 발생
- 키로 값을 검색
- 많은 응용에서 필요함
- #include <map> 필요

#### 맵 컨테이너 생성 예시

- 영한 사전을 저장하기 위한 맵 컨테이너 생성 및 활용
    - 영어 단어와 한글 단어를 쌍으로 저장하고 영어 단어로 검색

### STL 알고리즘 사용하기

#### 알고리즘 함수

- 템플릿 함수
- 전역 함수
    - STL 컨테이너 클래스의 멤버 함수가 아님
- iterator와 함께 작동

#### sort() 함수 사례

- 두 개의 매개 변수
    - 첫번째 매개 변수 : 소팅을 시작하는 원소의 주소
    - 두번째 매개 변수 : 소팅 범위의 마지막 원소 다음 주소

### auto를 이용하여 쉬운 변수 선언

#### C++에서 auto

- 기능
    - C++ 11부터 auto 선언의 의미 수정 : 컴파일러에게 변수선언문에서 추론하여 타입을 자동 선언하도록 지시
    - C++ 11 이전까지는 스택에 할당되는 지역 변수를 선언하는 키워드
- 장점
    - 복잡한 변수 선언을 간소하게, 긴 타입 선언 시 오타 줄임

#### auto의 기본 사용 사례

![image](https://github.com/choiht0904/Cpp_01/assets/77330457/b0903e39-9ccf-42ba-92c7-2dd7936d984f)
